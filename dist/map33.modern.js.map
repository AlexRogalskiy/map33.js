{"version":3,"file":"map33.modern.js","sources":["../src/material/QuadTextureMaterial.js","../src/index.js","../src/material/quadtexture_vert.glsl.js","../src/material/quadtexture_frag.glsl.js"],"sourcesContent":["import {\n  ShaderMaterial,\n  TextureLoader,\n  UniformsLib,\n} from 'three'\nimport vertexShader from './quadtexture_vert.glsl'\nimport fragmentShader from './quadtexture_frag.glsl'\n\nconst loader = new TextureLoader()\n\nconst QuadTextureMaterial = (urls) => {\n  return Promise.all(urls.map(url => loader.loadAsync(url))).then(maps => {\n    return new ShaderMaterial({\n      uniforms: {\n        mapNW: {value: maps[0]},\n        mapSW: {value: maps[1]},\n        mapNE: {value: maps[2]},\n        mapSE: {value: maps[3]},\n        ...UniformsLib.common,\n        ...UniformsLib.lights,\n        ...UniformsLib.fog,\n      },\n      vertexShader,\n      fragmentShader,\n      defines: {\n        USE_MAP: true,\n        USE_UV: true,\n      },\n      lights: true,\n      fog: true,\n    })\n  })\n}\n\nexport default QuadTextureMaterial\n","import getPixels from 'get-pixels'\nimport {\n  PlaneBufferGeometry,\n  Mesh,\n  MeshNormalMaterial,\n  Vector3,\n} from 'three'\nimport QuadTextureMaterial from './material/QuadTextureMaterial'\n\nconst tileMaterial = new MeshNormalMaterial({wireframe: true})\nconst baseTileSize = 600.\n\nclass Utils {\n  static long2tile (lon, zoom) {\n    return (lon + 180) / 360 * Math.pow(2, zoom)\n  }\n\n  static lat2tile (lat, zoom) {\n    return (\n      (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)\n      )\n  }\n\n  static geo2tile (geoLocation, zoom) {\n    const maxTile = Math.pow(2, zoom);\n    return {\n      x: Math.abs(Math.floor(Utils.long2tile(geoLocation[1], zoom)) % maxTile),\n      y: Math.abs(Math.floor(Utils.lat2tile(geoLocation[0], zoom)) % maxTile)\n    }\n  }\n\n  static tile2position(z, x, y, center, tileSize) {\n    const offsetAtZ = (z) => {\n      return {\n        x: center.x / Math.pow(2, 10 - z),\n        y: center.y / Math.pow(2, 10 - z),\n      };\n    };\n    const offset = offsetAtZ(z);\n    return {\n      x: (x - center.x - (offset.x % 1) + (center.x % 1)) * tileSize,\n      y: (-y + center.y + (offset.y % 1) - (center.y % 1)) * tileSize,\n      z: 0\n    }\n  }\n\n  static position2tile(z, x, y, center, tileSize) {\n    const centerPosition = Utils.tile2position(z, center.x, center.y, center, tileSize)\n    console.log(centerPosition)\n    const deltaX = Math.round((x - centerPosition.x) / tileSize)\n    const deltaY = Math.round(-(y - centerPosition.y) / tileSize)\n    return {x: deltaX + center.x, y: deltaY + center.y, z}\n  }\n}\n\nclass MapPicker {\n  constructor(camera, map, domElement, controls) {\n    this.vec = new Vector3(); // create once and reuse\n    this.position = new Vector3(); // create once and reuse\n    this.camera = camera\n    this.map = map\n    this.domElement = domElement\n    this.controls = controls\n\n    this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this))\n    this.domElement.addEventListener('dblclick', this.onMouseClick.bind(this))\n  }\n\n  computeWorldPosition(event) {\n    // cf. https://stackoverflow.com/a/13091694/343834\n    this.vec.set(\n      (event.clientX / window.innerWidth) * 2 - 1,\n      -(event.clientY / window.innerHeight) * 2 + 1,\n      0.5);\n\n    this.vec.unproject(this.camera);\n\n    this.vec.sub(this.camera.position).normalize();\n\n    var distance = -this.camera.position.z / this.vec.z;\n\n    this.position.copy(this.camera.position).add(this.vec.multiplyScalar(distance));\n  }\n\n  onMouseMove(event) {\n    // this.computeWorldPosition(event)\n  }\n\n  onMouseClick(event) {\n    this.computeWorldPosition(event)\n    this.map.addFromPosition(this.position.x, this.position.y)\n  }\n\n  go(lat, lon) {\n    this.map.clean()\n    this.map.geoLocation = [lat, lon]\n    this.map.init()\n  }\n}\n\nclass Source {\n  constructor(api, token, options) {\n    this.supportedApis = {\n      'osm': this.mapUrlOSM.bind(this),\n      'mapbox': this.mapUrlMapbox.bind(this),\n      'eox': this.mapUrlSentinel2Cloudless.bind(this),\n      'maptiler': this.mapUrlmapTiler.bind(this),\n    }\n    if (!(api in this.supportedApis)) {\n      throw new Error('Unknown source api');\n    }\n    this.api = api\n    this.token = token\n    this.options = options\n  }\n\n  mapUrlOSM(z, x, y) {\n    return `https://c.tile.openstreetmap.org/${z}/${x}/${y}.png`\n  }\n\n  mapUrlMapbox(z, x, y) {\n    return `https://api.mapbox.com/v4/mapbox.satellite/${z}/${x}/${y}@2x.jpg80?access_token=${this.token}`\n  }\n\n  mapUrlSentinel2Cloudless(z, x, y) {\n    // cf. https://tiles.maps.eox.at/wmts/1.0.0/WMTSCapabilities.xml\n    return `https://tiles.maps.eox.at/wmts?layer=s2cloudless_3857&style=default&tilematrixset=g&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image%2Fjpeg&TileMatrix=${z}&TileCol=${x}&TileRow=${y}`\n  }\n\n  mapUrlmapTiler(z, x, y) {\n    return `https://api.maptiler.com/tiles/satellite/${z}/${x}/${y}.jpg?key=${this.token}`\n  }\n\n  mapUrl(z, x, y) {\n    return this.supportedApis[this.api](z, x, y)\n  }\n\n}\n\nclass Tile {\n  constructor(map, z, x, y, size = baseTileSize) {\n    this.map = map\n    this.z = z\n    this.x = x\n    this.y = y\n    this.size = size\n    this.baseURL = \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium\"\n    this.shape = null\n    this.elevation = null\n    this.seamX = false\n    this.seamY = false\n  }\n\n  key() {\n    return `${this.z}/${this.x}/${this.y}`\n  }\n  keyNeighX() {\n    return `${this.z}/${this.x + 1}/${this.y}`\n  }\n  keyNeighY() {\n    return `${this.z}/${this.x}/${this.y + 1}`\n  }\n\n  url() {\n    return `${this.baseURL}/${this.z}/${this.x}/${this.y}.png`\n  }\n\n  mapUrl() {\n    return this.map.source.mapUrl(this.z, this.x, this.y)\n  }\n\n  computeElevation(pixels) {\n    this.shape = pixels.shape\n    const elevation = new Float32Array(pixels.shape[0] * pixels.shape[1])\n    for (let i = 0; i < pixels.shape[0]; i++) {\n      for (let j = 0; j < pixels.shape[1]; j++) {\n        const ij = i + pixels.shape[0] * j\n        const rgba = ij * 4\n        elevation[ij] =\n          pixels.data[rgba] * 256.0 +\n          pixels.data[rgba + 1] +\n          pixels.data[rgba + 2] / 256.0 -\n          32768.0\n      }\n    }\n    this.elevation = elevation\n  }\n\n  buildGeometry() {\n    const geometry = new PlaneBufferGeometry(\n      this.size,\n      this.size,\n      this.shape[0] / 2,\n      this.shape[1] / 2\n    )\n    const nPosition = Math.sqrt(geometry.attributes.position.count)\n    const nElevation = Math.sqrt(this.elevation.length)\n    const ratio = nElevation / (nPosition - 1)\n    let x, y\n    for (\n      // let i = nPosition;\n      let i = 0;\n      i < geometry.attributes.position.count - nPosition;\n      i++\n    ) {\n      // if (i % nPosition === 0 || i % nPosition === nPosition - 1) continue;\n      if (i % nPosition === nPosition - 1) continue\n      x = Math.floor(i / nPosition)\n      y = i % nPosition\n      geometry.attributes.position.setZ(\n        i,\n        this.elevation[\n          Math.round(Math.round(x * ratio) * nElevation + y * ratio)\n        ] * 0.045\n      )\n    }\n    geometry.computeVertexNormals()\n    this.geometry = geometry\n  }\n\n  childrens() {\n    return [\n      new Tile(this.map, this.z + 1, this.x * 2, this.y * 2),\n      new Tile(this.map, this.z + 1, this.x * 2, this.y * 2 + 1),\n      new Tile(this.map, this.z + 1, this.x * 2 + 1, this.y * 2),\n      new Tile(this.map, this.z + 1, this.x * 2 + 1, this.y * 2 + 1),\n    ]\n  }\n\n  buildMaterial() {\n    const urls = this.childrens().map(tile => tile.mapUrl())\n    return QuadTextureMaterial(urls)\n  }\n\n  buildmesh() {\n    this.buildMaterial().then((material) => {\n      this.mesh.material = material\n    })\n    this.mesh = new Mesh(this.geometry, tileMaterial)\n  }\n\n  fetch() {\n    return new Promise((resolve, reject) => {\n      getPixels(this.url(), (err, pixels) => {\n        if (err) console.error(err)\n        this.computeElevation(pixels)\n        this.buildGeometry()\n        this.buildmesh()\n        resolve(this)\n      })\n    })\n  }\n\n  setPosition(center) {\n    const position = Utils.tile2position(\n      this.z,\n      this.x,\n      this.y,\n      center,\n      this.size\n    )\n    this.mesh.position.set(...Object.values(position))\n  }\n\n  resolveSeamY(neighbor) {\n    const tPosition = this.mesh.geometry.attributes.position.count\n    const nPosition = Math.sqrt(tPosition)\n    const nPositionN = Math.sqrt(\n      neighbor.mesh.geometry.attributes.position.count\n    )\n    if (nPosition !== nPositionN) {\n      console.error(\"resolveSeamY only implemented for geometries of same size\")\n      return\n    }\n    for (let i = tPosition - nPosition; i < tPosition; i++) {\n      this.mesh.geometry.attributes.position.setZ(\n        i,\n        neighbor.mesh.geometry.attributes.position.getZ(\n          i - (tPosition - nPosition)\n        )\n      )\n    }\n  }\n\n  resolveSeamX(neighbor) {\n    const tPosition = this.mesh.geometry.attributes.position.count\n    const nPosition = Math.sqrt(tPosition)\n    const nPositionN = Math.sqrt(\n      neighbor.mesh.geometry.attributes.position.count\n    )\n    if (nPosition !== nPositionN) {\n      console.error(\"resolveSeamX only implemented for geometries of same size\")\n      return\n    }\n    for (let i = nPosition - 1; i < tPosition; i += nPosition) {\n      this.mesh.geometry.attributes.position.setZ(\n        i,\n        neighbor.mesh.geometry.attributes.position.getZ(i - nPosition + 1)\n      )\n    }\n  }\n\n  resolveSeams(cache) {\n    let worked = false\n    const neighY = cache[this.keyNeighY()]\n    const neighX = cache[this.keyNeighX()]\n    if (this.seamY === false && neighY && neighY.mesh) {\n      this.resolveSeamY(neighY)\n      this.seamY = true\n      worked = true\n    }\n    if (this.seamX === false && neighX && neighX.mesh) {\n      this.resolveSeamX(neighX)\n      this.seamX = true\n      worked = true\n    }\n    if (worked) {\n      this.mesh.geometry.attributes.position.needsUpdate = true\n      this.mesh.geometry.computeVertexNormals()\n    }\n  }\n}\n\nclass Map {\n  constructor (scene, camera, source, geoLocation, nTiles, zoom=10, options) {\n    this.scene = scene\n    this.camera = camera\n    this.source = source\n    this.geoLocation = geoLocation\n    this.nTiles = nTiles\n    this.zoom = zoom\n    this.options = options\n    this.tileSize = baseTileSize\n\n    this.tileCache = {};\n\n    this.init()\n  }\n\n  init() {\n    this.center = Utils.geo2tile(this.geoLocation, this.zoom)\n    console.log({loc: this.geoLocation, center: this.center})\n    const tileOffset = Math.floor(this.nTiles / 2)\n\n    for (let i = 0; i < this.nTiles; i++) {\n      for (let j = 0; j < this.nTiles; j++) {\n        const tile = new Tile(this, this.zoom, this.center.x + i - tileOffset, this.center.y + j - tileOffset)\n        this.tileCache[tile.key()] = tile\n      }\n    }\n\n    const promises = Object.values(this.tileCache).map(tile =>\n      tile.fetch().then(tile => {\n        tile.setPosition(this.center)\n        this.scene.add(tile.mesh)\n        return tile\n      })\n    )\n\n    Promise.all(promises).then(tiles => {\n      tiles.reverse().forEach(tile => {  // reverse to avoid seams artifacts\n        tile.resolveSeams(this.tileCache)\n      })\n    })\n\n  }\n\n  addFromPosition(posX, posY) {\n    const {\n      x,\n      y,\n      z\n    } = Utils.position2tile(this.zoom, posX, posY, this.center, this.tileSize)\n    console.log({x, y, z})\n    const tile = new Tile(this, this.zoom, x, y)\n\n    if (tile.key() in this.tileCache) return\n\n    this.tileCache[tile.key()] = tile\n    tile.fetch().then(tile => {\n      tile.setPosition(this.center)\n      this.scene.add(tile.mesh)\n    }).then(() => {\n      Object.values(this.tileCache).forEach(tile => tile.resolveSeams(this.tileCache))\n    })\n  }\n\n  clean() {\n    Object.values(this.tileCache).forEach(tile => {\n      this.scene.remove(tile.mesh)\n      tile.mesh.geometry.dispose();\n      ['mapSW', 'mapNW', 'mapSE', 'mapNE'].forEach(key => tile.mesh.material.uniforms[key].value.dispose())\n      tile.mesh.material.dispose()\n    })\n    this.tileCache = {}\n  }\n}\n\nexport {Map, Source, MapPicker}\n","export default `\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n`\n","export default `\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n// ####### custom uniforms #########\nuniform sampler2D mapNW;\nuniform sampler2D mapSW;\nuniform sampler2D mapNE;\nuniform sampler2D mapSE;\n// #################################\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\n  #ifdef USE_MAP\n\n  vec4 colorSW = mix(mix(texture2D(mapSW, vUv * 2.), vec4(0.), step(0.5, vUv.x)), vec4(0.), step(0.5, vUv.y));\n  vec4 colorNW = mix(mix(texture2D(mapNW, vUv * 2. + vec2(0., -1.)), vec4(0.), step(0.5, vUv.x)), vec4(0.), 1. - step(0.5, vUv.y));\n  vec4 colorSE = mix(mix(texture2D(mapSE, vUv * 2. + vec2(-1., 0.)), vec4(0.), 1. - step(0.5, vUv.x)), vec4(0.), step(0.5, vUv.y));\n  vec4 colorNE = mix(mix(texture2D(mapNE, vUv * 2. + vec2(-1., -1.)), vec4(0.), 1. - step(0.5, vUv.x)), vec4(0.), 1. - step(0.5, vUv.y));\n\n  // texelColor = mapTexelToLinear(texelColor);\n  diffuseColor *= colorSW + colorNW + colorNE + colorSE;\n\n  #endif\n\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n`\n"],"names":["loader","TextureLoader","tileMaterial","MeshNormalMaterial","wireframe","Utils","[object Object]","lon","zoom","Math","pow","lat","log","tan","PI","cos","geoLocation","maxTile","x","abs","floor","long2tile","y","lat2tile","z","center","tileSize","offset","offsetAtZ","centerPosition","tile2position","console","deltaX","round","deltaY","MapPicker","constructor","camera","map","domElement","controls","this","vec","Vector3","position","addEventListener","onMouseMove","bind","onMouseClick","computeWorldPosition","event","set","clientX","window","innerWidth","clientY","innerHeight","unproject","sub","normalize","distance","copy","add","multiplyScalar","addFromPosition","go","clean","init","Source","api","token","options","supportedApis","osm","mapUrlOSM","mapbox","mapUrlMapbox","eox","mapUrlSentinel2Cloudless","maptiler","mapUrlmapTiler","Error","mapUrl","Tile","size","baseURL","shape","elevation","seamX","seamY","key","keyNeighX","keyNeighY","url","source","computeElevation","pixels","Float32Array","i","j","ij","rgba","data","buildGeometry","geometry","PlaneBufferGeometry","nPosition","sqrt","attributes","count","nElevation","length","ratio","setZ","computeVertexNormals","childrens","buildMaterial","urls","tile","Promise","all","loadAsync","then","maps","ShaderMaterial","uniforms","mapNW","value","mapSW","mapNE","mapSE","UniformsLib","common","lights","fog","vertexShader","fragmentShader","defines","USE_MAP","USE_UV","buildmesh","material","mesh","Mesh","fetch","resolve","reject","getPixels","err","error","setPosition","Object","values","resolveSeamY","neighbor","tPosition","getZ","resolveSeamX","resolveSeams","cache","worked","neighY","neighX","needsUpdate","Map","scene","nTiles","tileCache","geo2tile","loc","tileOffset","promises","tiles","reverse","forEach","posX","posY","position2tile","remove","dispose"],"mappings":"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"}