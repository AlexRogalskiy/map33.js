import e from"get-pixels";import{TextureLoader as t,ShaderMaterial as i,UniformsLib as n,MeshNormalMaterial as s,Vector3 as o,PlaneBufferGeometry as a,Mesh as r}from"three";const l=new t,h=new s({wireframe:!0});class m{static long2tile(e,t){return(e+180)/360*Math.pow(2,t)}static lat2tile(e,t){return(1-Math.log(Math.tan(e*Math.PI/180)+1/Math.cos(e*Math.PI/180))/Math.PI)/2*Math.pow(2,t)}static geo2tile(e,t){const i=Math.pow(2,t);return{x:Math.abs(Math.floor(m.long2tile(e[1],t))%i),y:Math.abs(Math.floor(m.lat2tile(e[0],t))%i)}}static tile2position(e,t,i,n,s){const o=(e=>({x:n.x/Math.pow(2,10-e),y:n.y/Math.pow(2,10-e)}))(e);return{x:(t-n.x-o.x%1+n.x%1)*s,y:(-i+n.y+o.y%1-n.y%1)*s,z:0}}static position2tile(e,t,i,n,s){const o=m.tile2position(e,n.x,n.y,n,s);console.log(o);const a=Math.round((t-o.x)/s),r=Math.round(-(i-o.y)/s);return{x:a+n.x,y:r+n.y,z:e}}}class c{constructor(e,t,i,n){this.vec=new o,this.position=new o,this.camera=e,this.map=t,this.domElement=i,this.controls=n,this.domElement.addEventListener("mousemove",this.onMouseMove.bind(this)),this.domElement.addEventListener("dblclick",this.onMouseClick.bind(this))}computeWorldPosition(e){this.vec.set(e.clientX/window.innerWidth*2-1,-e.clientY/window.innerHeight*2+1,.5),this.vec.unproject(this.camera),this.vec.sub(this.camera.position).normalize();var t=-this.camera.position.z/this.vec.z;this.position.copy(this.camera.position).add(this.vec.multiplyScalar(t))}onMouseMove(e){}onMouseClick(e){this.computeWorldPosition(e),this.map.addFromPosition(this.position.x,this.position.y)}go(e,t){this.map.clean(),this.map.geoLocation=[e,t],this.map.init()}}class p{constructor(e,t,i){if(this.supportedApis={osm:this.mapUrlOSM.bind(this),mapbox:this.mapUrlMapbox.bind(this),eox:this.mapUrlSentinel2Cloudless.bind(this),maptiler:this.mapUrlmapTiler.bind(this)},!(e in this.supportedApis))throw new Error("Unknown source api");this.api=e,this.token=t,this.options=i}mapUrlOSM(e,t,i){return`https://c.tile.openstreetmap.org/${e}/${t}/${i}.png`}mapUrlMapbox(e,t,i){return`https://api.mapbox.com/v4/mapbox.satellite/${e}/${t}/${i}@2x.jpg80?access_token=${this.token}`}mapUrlSentinel2Cloudless(e,t,i){return`https://tiles.maps.eox.at/wmts?layer=s2cloudless_3857&style=default&tilematrixset=g&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image%2Fjpeg&TileMatrix=${e}&TileCol=${t}&TileRow=${i}`}mapUrlmapTiler(e,t,i){return`https://api.maptiler.com/tiles/satellite/${e}/${t}/${i}.jpg?key=${this.token}`}mapUrl(e,t,i){return this.supportedApis[this.api](e,t,i)}}class u{constructor(e,t,i,n,s=600){this.map=e,this.z=t,this.x=i,this.y=n,this.size=s,this.baseURL="https://s3.amazonaws.com/elevation-tiles-prod/terrarium",this.shape=null,this.elevation=null,this.seamX=!1,this.seamY=!1}key(){return`${this.z}/${this.x}/${this.y}`}keyNeighX(){return`${this.z}/${this.x+1}/${this.y}`}keyNeighY(){return`${this.z}/${this.x}/${this.y+1}`}url(){return`${this.baseURL}/${this.z}/${this.x}/${this.y}.png`}mapUrl(){return this.map.source.mapUrl(this.z,this.x,this.y)}computeElevation(e){this.shape=e.shape;const t=new Float32Array(e.shape[0]*e.shape[1]);for(let i=0;i<e.shape[0];i++)for(let n=0;n<e.shape[1];n++){const s=i+e.shape[0]*n,o=4*s;t[s]=256*e.data[o]+e.data[o+1]+e.data[o+2]/256-32768}this.elevation=t}buildGeometry(){const e=new a(this.size,this.size,this.shape[0]/2,this.shape[1]/2),t=Math.sqrt(e.attributes.position.count),i=Math.sqrt(this.elevation.length),n=i/(t-1);let s,o;for(let a=0;a<e.attributes.position.count-t;a++)a%t!=t-1&&(s=Math.floor(a/t),o=a%t,e.attributes.position.setZ(a,.045*this.elevation[Math.round(Math.round(s*n)*i+o*n)]));e.computeVertexNormals(),this.geometry=e}childrens(){return[new u(this.map,this.z+1,2*this.x,2*this.y),new u(this.map,this.z+1,2*this.x,2*this.y+1),new u(this.map,this.z+1,2*this.x+1,2*this.y),new u(this.map,this.z+1,2*this.x+1,2*this.y+1)]}buildMaterial(){return e=this.childrens().map(e=>e.mapUrl()),Promise.all(e.map(e=>l.loadAsync(e))).then(e=>new i({uniforms:{mapNW:{value:e[0]},mapSW:{value:e[1]},mapNE:{value:e[2]},mapSE:{value:e[3]},...n.common,...n.lights,...n.fog},vertexShader:"\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n",fragmentShader:"\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n// ####### custom uniforms #########\nuniform sampler2D mapNW;\nuniform sampler2D mapSW;\nuniform sampler2D mapNE;\nuniform sampler2D mapSE;\n// #################################\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\n  #ifdef USE_MAP\n\n  vec4 colorSW = mix(mix(texture2D(mapSW, vUv * 2.), vec4(0.), step(0.5, vUv.x)), vec4(0.), step(0.5, vUv.y));\n  vec4 colorNW = mix(mix(texture2D(mapNW, vUv * 2. + vec2(0., -1.)), vec4(0.), step(0.5, vUv.x)), vec4(0.), 1. - step(0.5, vUv.y));\n  vec4 colorSE = mix(mix(texture2D(mapSE, vUv * 2. + vec2(-1., 0.)), vec4(0.), 1. - step(0.5, vUv.x)), vec4(0.), step(0.5, vUv.y));\n  vec4 colorNE = mix(mix(texture2D(mapNE, vUv * 2. + vec2(-1., -1.)), vec4(0.), 1. - step(0.5, vUv.x)), vec4(0.), 1. - step(0.5, vUv.y));\n\n  // texelColor = mapTexelToLinear(texelColor);\n  diffuseColor *= colorSW + colorNW + colorNE + colorSE;\n\n  #endif\n\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n",defines:{USE_MAP:!0,USE_UV:!0},lights:!0,fog:!0}));var e}buildmesh(){this.buildMaterial().then(e=>{this.mesh.material=e}),this.mesh=new r(this.geometry,h)}fetch(){return new Promise((t,i)=>{e(this.url(),(e,i)=>{e&&console.error(e),this.computeElevation(i),this.buildGeometry(),this.buildmesh(),t(this)})})}setPosition(e){const t=m.tile2position(this.z,this.x,this.y,e,this.size);this.mesh.position.set(...Object.values(t))}resolveSeamY(e){const t=this.mesh.geometry.attributes.position.count,i=Math.sqrt(t);if(i===Math.sqrt(e.mesh.geometry.attributes.position.count))for(let n=t-i;n<t;n++)this.mesh.geometry.attributes.position.setZ(n,e.mesh.geometry.attributes.position.getZ(n-(t-i)));else console.error("resolveSeamY only implemented for geometries of same size")}resolveSeamX(e){const t=this.mesh.geometry.attributes.position.count,i=Math.sqrt(t);if(i===Math.sqrt(e.mesh.geometry.attributes.position.count))for(let n=i-1;n<t;n+=i)this.mesh.geometry.attributes.position.setZ(n,e.mesh.geometry.attributes.position.getZ(n-i+1));else console.error("resolveSeamX only implemented for geometries of same size")}resolveSeams(e){let t=!1;const i=e[this.keyNeighY()],n=e[this.keyNeighX()];!1===this.seamY&&i&&i.mesh&&(this.resolveSeamY(i),this.seamY=!0,t=!0),!1===this.seamX&&n&&n.mesh&&(this.resolveSeamX(n),this.seamX=!0,t=!0),t&&(this.mesh.geometry.attributes.position.needsUpdate=!0,this.mesh.geometry.computeVertexNormals())}}class d{constructor(e,t,i,n,s,o=10,a){this.scene=e,this.camera=t,this.source=i,this.geoLocation=n,this.nTiles=s,this.zoom=o,this.options=a,this.tileSize=600,this.tileCache={},this.init()}init(){this.center=m.geo2tile(this.geoLocation,this.zoom),console.log({loc:this.geoLocation,center:this.center});const e=Math.floor(this.nTiles/2);for(let t=0;t<this.nTiles;t++)for(let i=0;i<this.nTiles;i++){const n=new u(this,this.zoom,this.center.x+t-e,this.center.y+i-e);this.tileCache[n.key()]=n}const t=Object.values(this.tileCache).map(e=>e.fetch().then(e=>(e.setPosition(this.center),this.scene.add(e.mesh),e)));Promise.all(t).then(e=>{e.reverse().forEach(e=>{e.resolveSeams(this.tileCache)})})}addFromPosition(e,t){const{x:i,y:n,z:s}=m.position2tile(this.zoom,e,t,this.center,this.tileSize);console.log({x:i,y:n,z:s});const o=new u(this,this.zoom,i,n);o.key()in this.tileCache||(this.tileCache[o.key()]=o,o.fetch().then(e=>{e.setPosition(this.center),this.scene.add(e.mesh)}).then(()=>{Object.values(this.tileCache).forEach(e=>e.resolveSeams(this.tileCache))}))}clean(){Object.values(this.tileCache).forEach(e=>{this.scene.remove(e.mesh),e.mesh.geometry.dispose(),["mapSW","mapNW","mapSE","mapNE"].forEach(t=>e.mesh.material.uniforms[t].value.dispose()),e.mesh.material.dispose()}),this.tileCache={}}}export{d as Map,c as MapPicker,p as Source};
//# sourceMappingURL=map33.modern.js.map
